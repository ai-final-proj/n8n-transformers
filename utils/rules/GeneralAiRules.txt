Title: General AI Rules

Collection: Policies_And_Structure

Retrieve Always

------------------------------------------------------------
### START SECTION: Purpose

These rules ensure all AI Agents behave consistently and safely when interacting with the PostgreSQL scheduler database.  
They define strict boundaries for SQL generation, tool usage, normalization, and message passing.  

### END SECTION: Purpose
------------------------------------------------------------

### START SECTION: Core Rules

1. Table and Column Usage  
* Always use exact table and column names from the provided schema.  
* Never invent or hallucinate tables, columns, or values.  
* Always prefix with public. (e.g., public.user, public.cohort).  
* Do not assume relationships unless explicitly defined in the schema.  
* When multiple tables have similar column names (e.g., name, description), always qualify with the table alias or prefix to avoid ambiguity.  

2. Query Execution  
* Only one SQL query per turn.  
* Never chain queries in a single execution.  
* If multiple queries are needed, execute them in sequence across turns.  
* INSERT operations must always be treated as trial runs with rollback first.  
* UPDATE and DELETE operations must explicitly log which rows are targeted by ID to avoid silent data corruption.  

3. System Messages  
* System_Message must never be empty.  
* Always include:  
  - generalSystemRules (textual rules passed from previous agents).  
  - databaseTableSchema (structured schema info from previous agents).  
* If retriever returns partial or incomplete schema/rules, request again until full coverage is obtained.  

4. Outputs  
* Always return outputs as valid JSON with exactly the properties required by each Agent.  
* Never include tool call syntax, explanations, or raw execution logs in the output.  
* If required data is missing, use placeholders (<program_id>, <period_id>) and explain them in the summary.  
* Ensure JSON is strictly valid (double quotes, no trailing commas). Non-JSON responses are not allowed.  

5. Retrieve Always Sections  
* Must always be included, regardless of user input.  
Examples:  
* Insert Schedule Rules.  
* Mandatory constraints.  
* Schema usage notes.  
* Always fetch ENUM definitions (role_code, user_status, period_category) since they are critical for validation.  

6. Role and User Handling  
* Roles must always be resolved via:  
  public.user.role_id = public.system_role.id  
* Filter by system_role.code.  
* Codes include: admin, instructor, learner, replacement_instructor, visiting_instructor.  
* “Teaching roles” must always normalize to (instructor, visiting_instructor, replacement_instructor).  

7. Status Handling  
* User and schedule status fields accept only active or inactive.  
* Always filter with valid status values where relevant.  
* Default to status = active if the user request is vague about status.  

8. Query Form (Read-only)  
* Default to SELECT-only queries.  
* Do not use SELECT INTO, CREATE TEMP TABLE, or any DDL/DCL operations.  
* WITH/CTE is allowed only for read-only SELECTs.  

9. Parameterization and Injection Safety  
* Always use bind parameters ($1, $2, …); never interpolate user input into SQL.  
* Apply explicit type casts where appropriate (e.g., ::int, ::timestamptz).  
* Validate enum-coded inputs (role_code, user_status, period_category) against allowed values.  

10. Determinism and Performance  
* Include ORDER BY whenever returning rows to ensure deterministic results.  
* Apply a default LIMIT 100 unless a different bound is explicitly required.  
* Fully qualify columns and prefer explicit JOINs; never use SELECT *.  
* Favor index-friendly predicates; avoid wrapping indexed columns in functions in WHERE clauses.  

11. Pagination and NULL Handling  
* Support limit/offset or cursor pagination when returning large result sets.  
* If paginating, return a next-page pointer (e.g., next_offset or cursor) in outputs.  
* Use COALESCE only for presentation; do not change filtering semantics.  
* Do not equate NULL with empty strings or zeros.  

12. Timezone and Temporal Consistency  
* Treat timestamps as UTC and prefer timestamptz in comparisons.  
* Perform timezone conversion at presentation layers unless explicitly requested.  

13. Output Contracts (JSON)  
* Success: return strictly valid JSON with only the properties required by the receiving Agent.  
* Error: return JSON with an errors array and a concise human-readable summary; include placeholders (e.g., <program_id>) and explain them.  
* Never include tool call syntax, stack traces, or raw logs in outputs.  

14. Precedence and Source of Truth  
* When rules conflict across documents, General AI Rules take precedence over module-specific guidance.  
* DatabaseStructure files (DatabaseStructure*.txt) are the canonical source for table/column names and types.  
* When uncertain, re-retrieve schema/rules and prefer exact names from schema files.  

15. Versioning and Traceability  
* Include a version note in summaries when rules materially affect outputs (e.g., "GeneralAiRules v1.1").  
* Treat absent or stale rules as an error condition and request updated rules via the retriever.  

### END SECTION: Core Rules
------------------------------------------------------------

### START SECTION: Error Handling

* If a query fails due to missing schema elements, return:  
  - A summary explaining what is missing.  
  - A query with placeholders for missing IDs/values.  
* Never attempt to fix schema errors by fabricating columns or changing structure.  
* If the same error repeats more than once, escalate by explicitly marking the error as “unresolvable with current schema.”  

### END SECTION: Error Handling
------------------------------------------------------------

### START SECTION: Why These Rules Matter

* Prevents invalid or fabricated SQL queries.  
* Ensures downstream execution agents always receive consistent, database-valid queries.  
* Guarantees transparency between natural language requests and schema-aware outputs.  
* Creates a stable foundation for schedule generation, role resolution, and learner management.  
* Enforces reliability by making the system self-check and re-request schema/rules when incomplete.  

### END SECTION: Why These Rules Matter
------------------------------------------------------------
